"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const bcs_1 = require("@mysten/bcs");
const ChildProcess = __importStar(require("child_process"));
const Fs = __importStar(require("fs"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const task_names_2 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const neverthrow_1 = require("neverthrow");
const Path = __importStar(require("path"));
const toml = __importStar(require("toml"));
/***************************************************************************************
 *
 *   Wrappers for Result-based Error Handling
 *
 *   Functions in the js standard lib uses exceptions for error handling, of which
 *   the correctness is hard to reason about. Here are a few wrappers that transform
 *   them into Result-based APIs for easy error handling and chaining.
 *
 **************************************************************************************/
class ChainedError extends Error {
    constructor(message, cause) {
        super(message);
        if (cause === undefined) {
            this.causes = [];
        }
        else if (Array.isArray(cause)) {
            this.causes = cause;
        }
        else {
            this.causes = [cause];
        }
    }
}
async function resultifyAsync(f) {
    try {
        return (0, neverthrow_1.ok)(await f());
    }
    catch (e) {
        if (e instanceof Error) {
            return (0, neverthrow_1.err)(e);
        }
        else {
            throw new Error(`${e} is not an instance of Error -- this should not happen`);
        }
    }
}
async function readTextFile(path) {
    return resultifyAsync(() => {
        return Fs.promises.readFile(path, { encoding: "utf-8" });
    });
}
async function readBytecodeFile(path) {
    return resultifyAsync(() => {
        return Fs.promises.readFile(path, { encoding: "hex" });
    });
}
async function readDir(path) {
    return resultifyAsync(() => {
        return Fs.promises.readdir(path, { withFileTypes: true });
    });
}
async function executeChildProcess(cmd) {
    return new Promise((resolve, _reject) => {
        const proc = ChildProcess.exec(cmd, (err, stdout, stderr) => {
            resolve([err, stdout, stderr]);
        });
        proc.stdin.end();
    });
}
/***************************************************************************************
 *
 *   Utilities to List Move packages in the Contracts Directory
 *
 **************************************************************************************/
async function isMovePackage(path) {
    const stats = await Fs.promises.stat(path);
    if (stats.isDirectory()) {
        const manifestPath = Path.join(path.toString(), "Move.toml");
        const manifestStats = await Fs.promises.stat(manifestPath);
        return manifestStats.isFile();
    }
    return false;
}
async function listMovePackages(contractsPath) {
    const dirs = await Fs.promises.readdir(contractsPath);
    const promises = dirs.map(async (name, _idx, _arr) => {
        const path = Path.join(contractsPath.toString(), name.toString());
        const isMove = await isMovePackage(path);
        return isMove ? path : null;
    });
    return (await Promise.all(promises)).filter((path) => path !== null);
}
async function identifyMoveType(packagePath) {
    var _a;
    const moveTomlPath = Path.join(packagePath, "Move.toml");
    const moveTomlRes = await readTextFile(moveTomlPath);
    if (moveTomlRes.isErr()) {
        return (0, neverthrow_1.err)(new ChainedError(`Failed to find ${moveTomlPath}`, moveTomlRes.error));
    }
    // If the Move.toml file includes a `Sui` dependency it is considered a Sui project,
    // otherwise an Aptos project. We might need to require project type explicitly in the
    // Move.toml file because the default is assumed to be an Aptos project.
    const moveToml = toml.parse(moveTomlRes.value);
    const moveType = ((_a = moveToml === null || moveToml === void 0 ? void 0 : moveToml.dependencies) === null || _a === void 0 ? void 0 : _a.Sui) === undefined ? MoveType.Aptos : MoveType.Sui;
    return (0, neverthrow_1.ok)(moveType);
}
/***************************************************************************************
 *
 *   Build
 *
 *   Functions to build Move packages using the `move` executable.
 *
 **************************************************************************************/
async function locateMoveExecutablePath(type) {
    const [e, stdout, _stderr] = await executeChildProcess(type === MoveType.Aptos ? "which aptos" : "which sui");
    if (e !== null) {
        return (0, neverthrow_1.err)(e);
    }
    console.assert(stdout !== "");
    const lines = stdout.split(/\r?\n/);
    return (0, neverthrow_1.ok)(lines[0]);
}
class MoveBuildError {
    constructor(exec_err, stdout, stderr) {
        this.exec_err = exec_err;
        this.stdout = stdout;
        this.stderr = stderr;
    }
}
var MoveType;
(function (MoveType) {
    MoveType[MoveType["Aptos"] = 0] = "Aptos";
    MoveType[MoveType["Sui"] = 1] = "Sui";
})(MoveType || (MoveType = {}));
async function movePackageBuild(moveType, movePath, packagePath) {
    if (moveType === MoveType.Aptos) {
        // Rebuild every time, so clean up the build folder. `assume-no` is to keep the package cache at ~/.move
        let cmd = `${movePath} move clean --package-dir ${packagePath} --assume-no`;
        let [e, stdout, stderr] = await executeChildProcess(cmd);
        if (e !== null)
            return (0, neverthrow_1.err)(new MoveBuildError(e, stdout, stderr));
    }
    // Aptos and Sui uses different subcommands to build a package
    // Use the default bytecode version 6 for Aptos repo tag `aptos-node-v1.14.0`
    const cmd = moveType === MoveType.Aptos
        ? `${movePath} move compile --package-dir ${packagePath} --skip-fetch-latest-git-deps`
        : `${movePath} move build --path ${packagePath} --force --skip-fetch-latest-git-deps`;
    const [e, stdout, stderr] = await executeChildProcess(cmd);
    if (e !== null)
        return (0, neverthrow_1.err)(new MoveBuildError(e, stdout, stderr));
    return (0, neverthrow_1.ok)(undefined);
}
/***************************************************************************************
 *
 *   Artifact Generation
 *
 *   Functions to generate hardhat artifacts from the outputs of the Move compiler
 *   toolchain.
 *
 **************************************************************************************/
async function loadBytecode(packagePath, contractName) {
    const bytecodePath = Path.join(packagePath, "build", contractName, 'bytecode_modules', `${contractName}.mv`);
    let readFileRes = await readBytecodeFile(bytecodePath);
    if (readFileRes.isErr()) {
        return (0, neverthrow_1.err)(new ChainedError(`Failed to load bytecode from ${bytecodePath}`, readFileRes.error));
    }
    // Extract the byte array to serialize within the higher level enum
    const code = Uint8Array.from(Buffer.from(readFileRes.value, 'hex'));
    const evmContract = UMI_SERIALIZER.serialize({ Module: code }).toBytes();
    return (0, neverthrow_1.ok)(Buffer.from(evmContract).toString('hex'));
}
async function listCompiledContracts(packagePath) {
    const path = Path.join(packagePath, "build");
    const readDirRes = await readDir(path);
    if (readDirRes.isErr()) {
        return (0, neverthrow_1.err)(new ChainedError(`Failed to list compiled contracts in ${path}`, readDirRes.error));
    }
    const entries = readDirRes.value;
    const info = [];
    for (const entry of entries) {
        if (entry.isDirectory()) {
            const parsed = Path.parse(entry.name);
            // Skip Sui generated lock folder
            if (parsed.name === 'locks')
                continue;
            info.push(parsed.name);
        }
    }
    return (0, neverthrow_1.ok)(info);
}
async function generateArtifact(hardhatRootPath, packagePath, contractName) {
    let [loadbytecodeRes] = await Promise.all([loadBytecode(packagePath, contractName)]);
    if (loadbytecodeRes.isErr()) {
        return (0, neverthrow_1.err)(loadbytecodeRes.error);
    }
    let bytecode = loadbytecodeRes.value;
    if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
    }
    let sourcePath = Path.relative(hardhatRootPath, packagePath);
    let artifact = {
        "_format": "hh-move-artifact-1",
        "contractName": contractName,
        "sourceName": sourcePath,
        // TODO: Generate and include ABIs in the contract artifact
        "abi": [],
        "bytecode": bytecode,
        "deployedBytecode": bytecode,
        "linkReferences": {},
        "deployedLinkReferences": {}
    };
    return (0, neverthrow_1.ok)(artifact);
}
async function generateArtifactsForPackage(hardhatRootPath, packagePath) {
    let listRes = await listCompiledContracts(packagePath);
    if (listRes.isErr()) {
        return (0, neverthrow_1.err)(new ChainedError(`Failed to list compiled contracts in ${packagePath}`, listRes.error));
    }
    let contractNames = listRes.value;
    let genResults = await Promise.all(contractNames.map(contractName => generateArtifact(hardhatRootPath, packagePath, contractName)));
    let errors = [];
    let artifacts = [];
    for (let res of genResults) {
        if (res.isErr()) {
            errors.push(res.error);
        }
        else {
            artifacts.push(res.value);
        }
    }
    if (errors.length > 0) {
        return (0, neverthrow_1.err)(new ChainedError(`Failed to generate artifacts for ${packagePath}`, errors));
    }
    return (0, neverthrow_1.ok)(artifacts);
}
async function buildPackageAndGenerateArtifacts(hardhatRootPath, packagePath) {
    const moveTypeRes = await identifyMoveType(packagePath);
    if (moveTypeRes.isErr()) {
        return (0, neverthrow_1.err)(moveTypeRes.error);
    }
    const moveType = moveTypeRes.value;
    const locateRes = await locateMoveExecutablePath(moveTypeRes.value);
    if (locateRes.isErr()) {
        return (0, neverthrow_1.err)(new ChainedError("Failed to locate the `move executable`", locateRes.error));
    }
    const movePath = locateRes.value;
    const buildRes = await movePackageBuild(moveType, movePath, packagePath);
    if (buildRes.isErr()) {
        let e = buildRes.error;
        console.log(`\nFailed to build ${packagePath}\n${e.stdout}${e.stderr}`);
        return (0, neverthrow_1.err)(e);
    }
    let genArtifactsRes = await generateArtifactsForPackage(hardhatRootPath, packagePath);
    if (genArtifactsRes.isErr()) {
        let e = genArtifactsRes.error;
        console.log(`Failed to build ${packagePath}\n${e}`);
        return (0, neverthrow_1.err)(genArtifactsRes.error);
    }
    console.log(`Successfully built ${packagePath}`);
    return (0, neverthrow_1.ok)(genArtifactsRes.value);
}
/***************************************************************************************
 *
 *   Bytecode serializer from the generated Solidity or Move contract bytecode.
 *
 **************************************************************************************/
const UMI_SERIALIZER = bcs_1.bcs.enum('ScriptOrDeployment', {
    Script: bcs_1.bcs.byteVector(),
    Module: bcs_1.bcs.byteVector(),
    EvmContract: bcs_1.bcs.byteVector(),
});
const serializeSolidityBytecode = (bytecode) => {
    // Extract the byte array to serialize within the higher level enum
    const code = Uint8Array.from(Buffer.from(bytecode.replace('0x', ''), 'hex'));
    const evmContract = UMI_SERIALIZER.serialize({ EvmContract: code }).toBytes();
    return '0x' + Buffer.from(evmContract).toString('hex');
};
/***************************************************************************************
 *
 *   Move Compile Subtask (Entrypoint)
 *
 *   This adds a new subtask "compile:move" which is added to the queue when one runs
 *   `npx hardhat compile`. This task will build all the move contracts using the `move`
 *   executable and generate the artifacts hardhat requires for testing and deployment.
 *
 **************************************************************************************/
const TASK_COMPILE_MOVE = "compile:move";
(0, config_1.subtask)(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS, async (_, __, runSuper) => {
    const otherTasks = await runSuper();
    return [...otherTasks, TASK_COMPILE_MOVE];
});
(0, config_1.subtask)(TASK_COMPILE_MOVE)
    .addParam("quiet", undefined, undefined, config_1.types.boolean)
    .setAction(async (_, { artifacts, config }) => {
    let packagePaths = await listMovePackages(Path.join(config.paths.root, "contracts"));
    if (packagePaths.length == 0) {
        console.log("No Move contracts to compile");
        return;
    }
    let plural = packagePaths.length == 1 ? "" : "s";
    console.log("Building %d Move package%s...", packagePaths.length, plural);
    let buildResults = await Promise.all(packagePaths.map(path => buildPackageAndGenerateArtifacts(config.paths.root, path.toString())));
    let failedToBuildAll = false;
    console.assert(packagePaths.length == buildResults.length);
    for (let idx in packagePaths) {
        let packagePathRel = Path.relative(config.paths.root, packagePaths[idx].toString());
        let res = buildResults[idx];
        if (res.isOk()) {
            let contractNames = [];
            for (let artifact of res.value) {
                contractNames.push(artifact.contractName);
                await artifacts.saveArtifactAndDebugFile(artifact);
            }
            artifacts.addValidArtifacts([{ sourceName: packagePathRel, artifacts: contractNames }]);
        }
        else {
            failedToBuildAll = true;
        }
    }
    if (failedToBuildAll) {
        throw new Error("Failed to build one or more Move packages");
    }
});
(0, config_1.subtask)(task_names_2.TASK_COMPILE_SOLIDITY)
    .setAction(async (_, { artifacts }, runSuper) => {
    await runSuper();
    const names = await artifacts.getAllFullyQualifiedNames();
    names.forEach(name => {
        const artifact = artifacts.readArtifactSync(name);
        // Only update fresh builds. On a fresh build, the deployed and contract bytecodes start with same bytes.
        if (artifact.bytecode.slice(0, 6) === artifact.deployedBytecode.slice(0, 6)) {
            artifact.bytecode = serializeSolidityBytecode(artifact.bytecode);
            artifacts.saveArtifactAndDebugFile(artifact);
        }
    });
});
module.exports = {};
//# sourceMappingURL=index.js.map